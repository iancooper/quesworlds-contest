# 0004. Resolution Module

Date: 2026-01-26

## Status

Accepted

## Context

**Parent Requirement**: [specs/0001-questworlds-contest/requirements.md](../../specs/0001-questworlds-contest/requirements.md)

**Scope**: This ADR focuses on the Resolution module design, which handles dice rolling, success calculation, and winner determination. See [ADR-0001](0001-user-interface-architecture.md) for overall architecture and [ADR-0003](0003-framing-module.md) for the ContestFrame input.

The Resolution module must:

- Accept known dice rolls (provided by the DiceRoller module via the web layer)
- Calculate successes based on QuestWorlds rules:
  - Roll below TN = 1 success
  - Roll equal to TN = 2 successes (big success)
  - Roll above TN = 0 successes
  - Each mastery adds 1 success
- Determine the winner (more successes wins)
- Handle ties (higher roll wins)
- Calculate the degree of victory/defeat (difference in successes)

Key forces:

- Dice rolling is handled by a separate DiceRoller module
- The Resolution module is purely deterministic - given the same inputs, it always produces the same output
- Success calculation rules are well-defined and deterministic
- The module receives a complete ContestFrame from the Framing module and DiceRolls from the caller
- Results must be immutable for display and audit purposes

## Decision

We will implement the Resolution module as a purely deterministic component that calculates contest results from known dice rolls. Randomness is handled by the separate DiceRoller module (see [ADR-0006](0006-diceroller-module.md)), with the web layer orchestrating the interaction.

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                   QuestWorlds.Resolution                        │
│                                                                 │
│  Inputs:                                                        │
│    - ContestFrame (from Framing module)                         │
│    - DiceRolls (provided by caller, generated by DiceRoller)    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │        IContestResolver (Role: Success Calculator)       │   │
│  │  - Resolve(ContestFrame, DiceRolls) → ResolutionResult   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Output:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              ResolutionResult (Immutable)                │   │
│  │  - PlayerRoll, ResistanceRoll                            │   │
│  │  - PlayerSuccesses, ResistanceSuccesses                  │   │
│  │  - Winner (Player/Resistance/Tie)                        │   │
│  │  - Degree (0-3+)                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

Note: Internal helper classes for success calculation and winner determination may emerge through refactoring as the implementation grows.

### Key Components

#### Roles and Responsibilities

**IContestResolver** (Role: Success Calculator)

- **Knowing**: QuestWorlds success rules, comparison and tie-breaking rules
- **Doing**: Calculate successes from known rolls, determine winner
- **Deciding**: Who wins and by how much

**DiceRolls** (Value Object)

- **Knowing**: Player roll and resistance roll values
- **Doing**: Nothing
- **Deciding**: Nothing

**ResolutionResult** (Value Object)

- **Knowing**: All resolution data (rolls, successes, winner, degree)
- **Doing**: Nothing
- **Deciding**: Nothing

Note: Internal helper methods or classes for success calculation and winner determination may emerge through refactoring as the implementation grows.

### Domain Model

```csharp
namespace QuestWorlds.Resolution;

/// <summary>
/// Represents a pair of D20 dice rolls for a contest.
/// </summary>
public readonly record struct DiceRolls(int PlayerRoll, int ResistanceRoll);

/// <summary>
/// The winner of a contest.
/// </summary>
public enum ContestWinner
{
    Player,
    Resistance,
    Tie
}

/// <summary>
/// Immutable result of contest resolution.
/// </summary>
public sealed record ResolutionResult
{
    public int PlayerRoll { get; init; }
    public int ResistanceRoll { get; init; }
    public int PlayerSuccesses { get; init; }
    public int ResistanceSuccesses { get; init; }
    public ContestWinner Winner { get; init; }
    public int Degree { get; init; }
}
```

### Interfaces

```csharp
namespace QuestWorlds.Resolution;

/// <summary>
/// Resolves a contest by calculating successes and determining the winner from known dice rolls.
/// </summary>
public interface IContestResolver
{
    /// <summary>
    /// Resolves a contest with the given dice rolls. Purely deterministic.
    /// </summary>
    /// <param name="frame">The contest frame with target numbers</param>
    /// <param name="rolls">The dice rolls (from DiceRoller module)</param>
    /// <returns>The resolution result with successes, winner, and degree</returns>
    ResolutionResult Resolve(ContestFrame frame, DiceRolls rolls);
}
```

### Implementations

The implementation starts simple. Internal helper classes may emerge through refactoring as complexity grows.

```csharp
namespace QuestWorlds.Resolution;

internal class ContestResolver : IContestResolver
{
    /// <summary>
    /// Resolves a contest with known dice rolls. Purely deterministic.
    /// </summary>
    public ResolutionResult Resolve(ContestFrame frame, DiceRolls rolls)
    {
        if (!frame.IsReadyForResolution)
            throw new InvalidOperationException("Contest frame is not ready for resolution");

        // Calculate successes for each side
        var playerSuccesses = CalculateSuccesses(rolls.PlayerRoll, frame.GetPlayerTargetNumber()!.Value);
        var resistanceSuccesses = CalculateSuccesses(rolls.ResistanceRoll, frame.Resistance);

        // Determine winner
        var (winner, degree) = DecideWinner(
            playerSuccesses, rolls.PlayerRoll,
            resistanceSuccesses, rolls.ResistanceRoll);

        return new ResolutionResult
        {
            PlayerRoll = rolls.PlayerRoll,
            ResistanceRoll = rolls.ResistanceRoll,
            PlayerSuccesses = playerSuccesses,
            ResistanceSuccesses = resistanceSuccesses,
            Winner = winner,
            Degree = degree
        };
    }

    private int CalculateSuccesses(int roll, TargetNumber targetNumber)
    {
        // Base successes from the roll
        int baseSuccesses = roll == targetNumber.EffectiveBase ? 2  // Big success
                          : roll < targetNumber.EffectiveBase ? 1   // Success
                          : 0;                                       // Failure

        return baseSuccesses + targetNumber.Masteries;
    }

    private (ContestWinner Winner, int Degree) DecideWinner(
        int playerSuccesses, int playerRoll,
        int resistanceSuccesses, int resistanceRoll)
    {
        var difference = playerSuccesses - resistanceSuccesses;

        if (difference > 0)
            return (ContestWinner.Player, difference);
        if (difference < 0)
            return (ContestWinner.Resistance, Math.Abs(difference));

        // Tie-breaker: higher roll wins with 0 degree
        if (playerRoll > resistanceRoll)
            return (ContestWinner.Player, 0);
        if (resistanceRoll > playerRoll)
            return (ContestWinner.Resistance, 0);

        return (ContestWinner.Tie, 0);
    }
}
```

### Access Modifiers and Encapsulation

Only the resolver interface and result types are public. The implementation is internal.

**Public API** (visible to other modules):

```csharp
public interface IContestResolver { ... }
public readonly record struct DiceRolls { ... }
public sealed record ResolutionResult { ... }
public enum ContestWinner { ... }
```

**Internal Implementation** (hidden from consumers):

```csharp
internal class ContestResolver : IContestResolver { ... }
// Success calculation and winner determination logic starts in ContestResolver
// and may be extracted to internal helper classes through refactoring
```

**Dependency Injection Registration** (in module):

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddResolutionModule(this IServiceCollection services)
    {
        services.AddSingleton<IContestResolver, ContestResolver>();
        return services;
    }
}
```

### Testing Strategy

Tests target `IContestResolver` (public interface). Since the module is purely deterministic, tests simply pass known `DiceRolls` values and verify the expected results:

```csharp
[Fact]
public void Resolve_WithKnownRolls_ReturnsExpectedOutcome()
{
    var resolver = new ContestResolver();
    var frame = new ContestFrame("Test prize", new TargetNumber(10));
    frame.SetPlayerAbility("Swordfighting", new Rating(15));

    // Player rolls 5 (below TN 15 = success), Resistance rolls 12 (above TN 10 = fail)
    var result = resolver.Resolve(frame, new DiceRolls(5, 12));

    Assert.Equal(ContestWinner.Player, result.Winner);
}
```

**Important**: We do NOT use `InternalsVisibleTo`. Internal classes should emerge through refactoring as the implementation grows, not be test-driven directly. Tests always go through the public `IContestResolver` interface.

**Note**: There is no need to mock a dice roller in tests - the randomness is handled by the separate DiceRoller module (see [ADR-0006](0006-diceroller-module.md)), and the Resolution module receives known values.

## Consequences

### Positive

- **Purely Deterministic**: Given the same inputs, always produces the same output - trivially testable
- **Simple**: Single method interface, no randomness to manage
- **Immutable Results**: ResolutionResult cannot be accidentally modified
- **Clear Contract**: Well-defined input (ContestFrame, DiceRolls) and output (ResolutionResult)
- **Separation of Concerns**: Randomness handled elsewhere, this module focuses on game logic

### Negative

- **Caller Responsibility**: The web layer must remember to use DiceRoller before calling Resolution

### Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Edge case in success calculation | Comprehensive unit tests for all combinations |
| Tie-breaking rule confusion | Clear documentation and tests |
| Caller forgets to roll dice | DiceRolls is a required parameter - compile-time enforcement |

## Alternatives Considered

### 1. Two Overloads (deterministic + random)

Have both `Resolve(frame, rolls)` and `Resolve(frame)` where the latter generates random rolls internally. Rejected because:

- Mixes concerns - the Resolution module should focus on calculation, not randomness
- Makes the module impure and harder to reason about
- The web layer is the appropriate place to orchestrate dice rolling

### 2. Injectable IDiceRoller Interface in Resolution Module

Make `IDiceRoller` internal to Resolution and inject it. Rejected because:

- Still mixes concerns within the module
- Requires mocking in tests
- Separate DiceRoller module is cleaner

### 3. InternalsVisibleTo for Testing

Expose internals to test project. Rejected because:

- Tests should only target public interfaces
- Internal classes should emerge from refactoring, not be test-driven
- Couples tests to implementation details

### 4. Return Tuple Instead of ResolutionResult

Return `(int, int, int, int, ...)` instead of a record. Rejected because:

- Less readable
- No named properties
- Harder to extend

## References

- Requirements: [specs/0001-questworlds-contest/requirements.md](../../specs/0001-questworlds-contest/requirements.md)
- Related ADRs:
  - [0001-user-interface-architecture.md](0001-user-interface-architecture.md) - Overall architecture
  - [0002-session-management.md](0002-session-management.md) - Session management
  - [0003-framing-module.md](0003-framing-module.md) - ContestFrame input
  - [0005-outcome-module.md](0005-outcome-module.md) - Consumes ResolutionResult
  - [0006-diceroller-module.md](0006-diceroller-module.md) - Provides DiceRolls
- External references:
  - [QuestWorlds SRD - Simple Contests](https://questworlds.chaosium.com/)
